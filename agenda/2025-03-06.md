### Memory-safe High-performance Async ROS Programming: A Preview

Interoperability often involves managing complex interactions between devices. These interactions may be transmissions of data or they may be physical activities that need to take place according to a specific procedure. In either case, good use of async programming is necessary to prevent processes from stalling while waiting for units of action to finish. Async programming is especially important when one process is managing multiple agents simultaneously.

Async programming is also notoriously difficult to do correctly. Traditional imperative programming is good for describing linear sequential steps, but quickly becomes difficult to follow when it needs to describe multiple interwoven activities. Race conditions are endemic in async programming, including data races which can violate memory safety, leading to bugs that are extremely difficult to fix. Even worse, these bugs can open programs up to security vulnerabilities.

This talk will provide a preview of some work in progress being done for [`rclrs`](https://github.com/ros2-rust/ros2_rust), a community-driven ROS client library for the Rust programming language. The upcoming features will allow `rclrs` to support Rust's high performance async programming capabilities, with memory safety guaranteed at compile time. We will look at the (working draft) API for these features and especially cover how the API differs from `rclcpp` and `rclpy` in order to take advantage of the unique characteristics of the Rust language, making many common use cases of async programming intuitive and fool-proof.
